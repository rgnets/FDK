#!/usr/bin/env dart

import 'package:rgnets_fdk/core/services/mock_data_service.dart';
import 'package:rgnets_fdk/features/devices/data/datasources/device_mock_data_source.dart';
import 'package:rgnets_fdk/core/config/environment.dart';

/// Diagnostic script to trace mock data flow and identify why production format isn't showing
void main() async {
  print('MOCK DATA FLOW DIAGNOSTIC');
  print('=' * 80);
  
  // Set environment to development to ensure mock data is used
  EnvironmentConfig.setEnvironment(Environment.development);
  print('\n1. ENVIRONMENT CHECK:');
  print('   isDevelopment: ${EnvironmentConfig.isDevelopment}');
  print('   useSyntheticData: ${EnvironmentConfig.useSyntheticData}');
  
  // Step 1: Check raw mock data from MockDataService
  print('\n2. RAW MOCK DATA FROM MockDataService:');
  print('-' * 50);
  
  final mockService = MockDataService();
  final devices = mockService.getMockDevices();
  
  print('Total devices in MockDataService: ${devices.length}');
  
  // Check first few access points
  print('\nFirst 5 Access Points (raw Device objects):');
  final aps = devices.where((d) => d.type == 'access_point').take(5).toList();
  for (final ap in aps) {
    print('  ID: ${ap.id.padRight(10)} Name: ${ap.name}');
  }
  
  // Check first few switches
  print('\nFirst 5 Switches (raw Device objects):');
  final switches = devices.where((d) => d.type == 'switch').take(5).toList();
  for (final sw in switches) {
    print('  ID: ${sw.id.padRight(15)} Name: ${sw.name}');
  }
  
  // Step 2: Check JSON generated for API simulation
  print('\n3. JSON GENERATED BY MockDataService:');
  print('-' * 50);
  
  final apJson = mockService.getMockAccessPointsJson();
  final switchJson = mockService.getMockSwitchesJson();
  
  print('Access Points JSON (first 3):');
  final apResults = apJson['results'] as List<dynamic>;
  for (final ap in apResults.take(3)) {
    print('  ID: ${ap['id']}');
    print('  Name: ${ap['name']}');
    print('  Online: ${ap['online']}');
    print('');
  }
  
  print('Switches JSON (first 3):');
  final switchResults = switchJson['results'] as List<dynamic>;
  for (final sw in switchResults.take(3)) {
    print('  ID: ${sw['id']}');
    print('  Name: ${sw['name']}');
    print('  Online: ${sw['online']}');
    print('');
  }
  
  // Step 3: Check how DeviceMockDataSourceImpl parses the JSON
  print('\n4. PARSED BY DeviceMockDataSourceImpl:');
  print('-' * 50);
  
  final mockDataSource = DeviceMockDataSourceImpl(
    mockDataService: mockService,
  );
  
  final deviceModels = await mockDataSource.getDevices();
  print('Total DeviceModels from data source: ${deviceModels.length}');
  
  print('\nFirst 5 Access Point Models:');
  final apModels = deviceModels.where((d) => d.type == 'access_point').take(5).toList();
  for (final model in apModels) {
    print('  ID: ${model.id.padRight(10)} Name: ${model.name}');
  }
  
  print('\nFirst 5 Switch Models:');
  final switchModels = deviceModels.where((d) => d.type == 'switch').take(5).toList();
  for (final model in switchModels) {
    print('  ID: ${model.id.padRight(15)} Name: ${model.name}');
  }
  
  // Step 4: Analyze name format
  print('\n5. NAME FORMAT ANALYSIS:');
  print('-' * 50);
  
  // Check if names follow production format
  void analyzeFormat(String name, String type) {
    print('\nAnalyzing: $name');
    
    // Expected format: [Type][Building]-[Floor]-[Serial]-[Model]-[RoomDesignation]
    // e.g., AP1-2-0030-AP520-RM205
    
    if (type == 'access_point') {
      if (name.startsWith('AP') && name.contains('-RM')) {
        final parts = name.split('-');
        if (parts.length >= 5) {
          print('  ✓ Follows production format');
          print('    Building: ${parts[0].substring(2)}');
          print('    Floor: ${parts[1]}');
          print('    Serial: ${parts[2]}');
          print('    Model: ${parts[3]}');
          print('    Room: ${parts[4]}');
        } else {
          print('  ✗ Wrong number of parts: ${parts.length}');
        }
      } else {
        print('  ✗ Does not follow production format');
        print('    Expected: AP[b]-[f]-[serial]-[model]-RM[room]');
      }
    } else if (type == 'switch') {
      if (name.startsWith('SW') && (name.contains('-RM') || name.contains('-MDF') || name.contains('-IDF'))) {
        final parts = name.split('-');
        if (parts.length >= 5) {
          print('  ✓ Follows production format');
        } else {
          print('  ✗ Wrong number of parts: ${parts.length}');
        }
      } else {
        print('  ✗ Does not follow production format');
        print('    Expected: SW[b]-[f]-[serial]-[model]-[RM|MDF|IDF]');
      }
    }
  }
  
  // Analyze a few device names
  if (apModels.isNotEmpty) {
    analyzeFormat(apModels.first.name, 'access_point');
  }
  if (switchModels.isNotEmpty) {
    analyzeFormat(switchModels.first.name, 'switch');
  }
  
  // Summary
  print('\n6. SUMMARY:');
  print('-' * 50);
  print('Data flow:');
  print('1. MockDataService creates Device objects with production-format names');
  print('2. MockDataService.getMockAccessPointsJson() converts to JSON');
  print('3. DeviceMockDataSourceImpl parses JSON back to DeviceModel');
  print('4. Names should be preserved throughout this flow');
  
  print('\nIf names are NOT in production format, check:');
  print('- Are we running the latest compiled code?');
  print('- Is hot reload picking up the changes?');
  print('- Try: flutter clean && flutter pub get && flutter run');
}