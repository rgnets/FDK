Implementation Plan (Iteration 10 - RxgChannel-aligned)
Goal: Rebuild FDK app to match ATT-FE-Tool functionality using RxgChannel WebSocket API
Confidence Score: 100/100

================================================================================
1) WEBSOCKET SYSTEM DESIGN
================================================================================

1.1 Connection and Session Lifecycle
- States: disconnected -> connecting -> authorizing -> loading_initial -> ready -> degraded -> reconnecting
- Authentication: The WebSocket connection is authenticated during the ActionCable connection handshake using one of:
  - Authorization header: `Authorization: Bearer <api_key>`
  - Query param: `?api_key=<api_key>` (fallback if headers are not supported)
  - Session cookie (admin/account web sessions)
- No auth.login/auth.result exchange; the server identifies the user during the connection handshake.
- Reconnection: Reconnect with the same API key/session cookie. If rejected (401/403), prompt for credentials again.
- Secure Transport: Always use `wss://` and the configured ActionCable mount path.

1.2 Message Envelope
ActionCable wraps all messages. The client sends `subscribe` and `message` commands
with a JSON `identifier` and JSON `data` payload. The server responds with simple
JSON objects (no nested envelope) and an `action` field.
```json
// Subscribe to RxgChannel
{"command":"subscribe","identifier":"{\"channel\":\"RxgChannel\"}"}

// Invoke a channel method (data is a JSON string)
{"command":"message","identifier":"{\"channel\":\"RxgChannel\"}","data":"{\"action\":\"resource_action\",\"resource_type\":\"access_points\",\"crud_action\":\"index\",\"page\":1,\"request_id\":\"req-1\"}"}
```

1.3 Core Message Types
Channel events (server -> client):
- connected                     // initial connection ack (action: "connected")
- subscription_confirmed        // resource subscription added/removed
- subscription_rejected         // bad resource or permission denied
- current_subscriptions         // list of resource types
- resource_response             // CRUD responses + broadcasts
- capabilities / all_capabilities
- error                         // status + error string

Channel methods (client -> server data.action):
- subscribe_to_resource         -> { resource_type }
- unsubscribe_from_resource     -> { resource_type }
- get_subscriptions             -> {}
- get_capabilities              -> { resource_type? }
- resource_action               -> { resource_type, crud_action, id?, params?, request_id? }
- create_resource               -> { resource_type, params, request_id? }
- update_resource               -> { resource_type, id, params, request_id? }
- destroy_resource              -> { resource_type, id, request_id? }

Extra actions are invoked via `resource_action` with `crud_action` set to the action name
defined on the controller (discoverable via get_capabilities).

1.4 Initial Load and Synchronization
To prevent race conditions where broadcasts arrive before the initial state is loaded:
1. State: The client enters a `loading_initial` state after the ActionCable connection is established.
2. Queueing: While in this state, all incoming `resource_response` broadcasts are queued.
3. Initial Loads: The client issues `resource_action` index requests for all required resource types
   (access_points, media_converters, switch_devices, pms_rooms, health_notices, pms_properties) and paginates using `page`/`page_size`.
4. Handling Pagination: Use `count`, `page`, `page_size`, `total_pages` to request all pages.
5. Applying Initial Data: Populate the store with the full result sets.
6. Processing Queue: Transition to `ready` and apply queued broadcasts in arrival order.
7. Normal Operation: Apply `resource_response` messages in real time.

1.5 Data Versioning
- Prefer server as source of truth; no explicit version field is guaranteed.
- If a resource includes `updated_at`, use it to ignore stale updates.
- Otherwise, apply last-write-wins in arrival order and rely on server errors for conflicts.

1.6 Resource Type Mapping (rXg)
- Devices:
  - Access Points: resource_type = access_points
  - ONTs (Media Converters): resource_type = media_converters
  - Switches: resource_type = switch_devices
- Rooms: resource_type = pms_rooms
- Issues: resource_type = health_notices
- Property metadata/name: resource_type = pms_properties (index/show)
- Speed tests: resource_type = speed_test_results (create/list)

1.7 Resource List by Screen (Single Checklist)
| Screen | Primary Resources | Key Actions |
|--------|-------------------|-------------|
| OnboardingView | none | local-only |
| AuthScreen | none | connect ActionCable with api_key |
| MainViewUnified | access_points, media_converters, switch_devices, pms_rooms, health_notices, pms_properties | index loads + subscribe_to_resource |
| HomeView | pms_properties, health_notices, access_points, media_converters, switch_devices, pms_rooms | index + derived metrics |
| DevicesView | access_points, media_converters, switch_devices | index, search/order, destroy_resource |
| IssuesView | health_notices | index, search/order |
| RoomReadinessView | pms_rooms, access_points, media_converters, health_notices | index + derived status |
| RoomDetailView | pms_rooms, access_points, media_converters, health_notices, speed_test_results | show/index filtered by room_id/pms_room_id |
| DeviceDetailView (AP) | access_points, health_notices, speed_test_results | show, resource_action led, update_resource images |
| DeviceDetailView (ONT) | media_converters, health_notices | show, update_resource images |
| DeviceDetailView (Switch) | switch_devices, health_notices | show |
| NoteEditView | devices | update_resource note |
| BarcodeScanner | access_points, media_converters, switch_devices, pms_rooms | register_ap_device/register_ont_device, create/update |
| ConnectionView | none | get_subscriptions, disconnect/reconnect |

================================================================================
2) DATA STORE DESIGN
================================================================================

2.1 In-Memory State Structure
```
AppState {
  connection: {
    status: disconnected|connecting|authorizing|loading_initial|ready|degraded|reconnecting,
    latencyMs: number,
    lastHeartbeat: DateTime,
    reconnectAttempts: number
  },
  credentials: {
    fqdn: string,
    username: string,
    apiKey: string, // Long-lived, stored securely
    isAuthenticated: bool
  },
  property: {
    name: string,
    metadata: {}
  },
  devices: Map<id, Device>,
  rooms: Map<id, Room>,           // pms_rooms resource
  issues: Map<id, Issue>,         // health_notices resource
  images: Map<device_id, List<Image>>,
  speedtests: Map<room_id, List<Speedtest>>,
  onboarding: Map<device_id, OnboardingState>,
  commandQueue: List<QueuedCommand>,
  updateQueue: List<UpdateMessage>, // For initial-load sync

  // Derived (computed on access)
  devicesByRoom: computed,
  issuesByDevice: computed,
  roomMetrics: computed
}
```
(The rest of section 2 remains the same)

2.3 Selectors (Derived State)
- selectDeviceById(id) -> Device?
- selectDevicesByType(type) -> List<Device>
- selectDevicesByRoom(roomId) -> List<Device>
- selectOnlineDeviceCount() -> int
- selectOfflineDeviceCount() -> int
- selectDeviceCountByType(type) -> { online, offline, total }
- selectRoomById(id) -> Room?
- selectRoomMetrics(roomId) -> RoomMetrics
- selectRoomReadinessSummary() -> { ready, partial, down, empty }
- selectIssuesByDevice(deviceId) -> List<Issue>
- selectIssuesBySeverity(severity) -> List<Issue>
- selectIssueCountBySeverity() -> { critical, warning, info }
- selectHealthScore() -> int (0-100)
- selectSpeedtestsByRoom(roomId) -> List<Speedtest>
- selectImagesByDevice(deviceId) -> List<Image>

2.4 Health Score Calculation
```
healthScore = baseScore - deductions
baseScore = (onlineDevices / totalDevices) * 100
deductions = (criticalIssues * 5) + (warningIssues * 2) + (infoIssues * 1)
clamp(healthScore, 0, 100)
```

2.5 Persistence Layer
- Serialize state to SQLite/Drift on updates (debounced 500ms)
- Load from disk on cold start
- Clear on logout
- Support offline browsing from cached state

================================================================================
3) VIEW MAPPING (from OldAppReport.txt)
================================================================================

3.1 MainViewUnified (main_view.dart)
Purpose: Root shell with bottom navigation

Implementation:
- LiveNavBar with 5 tabs: Home, Settings, Scanner, Devices, Rooms, Issues,
- Scanner accessible via FAB or nav item
- On mount: Connect WebSocket (ActionCable) with API key -> subscribe to needed resources -> run initial index loads
- Initialization overlay with progress messages:
  1. "Connecting to server..."
  2. "Authorizing..."
  3. "Loading devices..."
  4. "Loading rooms..."
  5. "Loading issues..."
  6. "Ready"
- Bind to connection.status for connectivity indicator
- Re-run initial index loads on reconnect after disconnect

3.2 OnboardingView (onboarding_view.dart)
Purpose: First-time user welcome

Implementation:
- 2-page PageView carousel with dots indicator
- Page 1: Welcome hero image, heading, description, Continue button
- Page 2: rXg setup instructions with animated GIF, "Connect to rXg" button
- On complete: Navigate to auth/scanner screen
- Store onboarding_completed flag in SharedPreferences

3.3 AuthScreen / CredentialEntryView
Purpose: Login via QR scan or manual entry

Implementation:
- Tab or toggle: QR Scan | Manual Entry
- QR Scan: Use camera to scan rXg-generated QR containing { fqdn, login, api_key }
- Manual Entry:
  - Form fields: FQDN, Login, API Key
  - JSON input toggle: paste { "fqdn": "...", "login": "...", "api_key": "..." }
- On submit: Connect ActionCable with API key in Authorization header (or `?api_key=` param)
- Handle connection failure: show message, remain on auth screen
- Validate before submit: non-empty fields, valid FQDN format

3.4 BarcodeScanner (scanner_screen.dart)
Purpose: Device provisioning and lookup

Implementation:
- Modes: Credential QR | Device Registration | Device/Room Lookup
- Mode selector at top of screen

Device Registration Flow:
1. Scan device barcode (MAC or Serial Number)
2. Show registration bottom sheet modal
3. Room selection: Searchable list from rooms store
4. Device assignment options:
   a. "Create New Device" - provision new device record
   b. "Assign to Designed Device" - select from unassigned devices in room
5. Send a resource_action extra action based on device type:
   - AP: resource_type = access_points, crud_action = register_ap_device
   - ONT: resource_type = media_converters, crud_action = register_ont_device
   - Switch: create_resource or update_resource on switch_devices (no register action)
   - params: room_id/pms_room_id, mac, serial_number, existing_device_id (if assigning)
6. Handle resource_response/error: success -> show confirmation, navigate to device
7. Mismatch detection: Compare scanned data with expected values

Device/Room Lookup Flow:
1. Scan device barcode or room plaque QR
2. Query store for matching device/room
3. Navigate directly to DeviceDetail or RoomDetail

3.5 HomeView (home_screen.dart)
Purpose: Dashboard overview

Implementation:
- Property Name Card: from pms_properties (or account metadata) in store
- Health Score Gauge: selectHealthScore() - circular progress 0-100
- Quick Stats Panel:
  - Total devices: devices.length
  - Online %: (online / total) * 100
  - Last refresh: connection.lastHeartbeat formatted
- Room Readiness Card: selectRoomReadinessSummary() -> Ready/Not Ready counts
- Issue Breakdown: selectIssueCountBySeverity() -> Critical/Warning/Info badges
- Devices Overview: selectDeviceCountByType() for Switch/AP/ONT
- Speed Test Card: Button to navigate to speed test screen or run test
- Pull-to-refresh: Re-run index loads for devices/rooms/issues

3.6 ConnectionView (connection_view.dart -> part of Settings)
Purpose: Connection status and session management

Implementation:
- Connection Status Section:
  - Internet: derived from connection.status != disconnected
  - Server: connection.status in [authorizing, ready, degraded]
  - Auth: credentials.isAuthenticated
  - Color indicators: green/yellow/red
- Performance Metrics:
  - Latency: connection.latencyMs + "ms"
  - Quality: excellent (<100ms), good (<300ms), fair (<500ms), poor (>500ms)
- Data Sync Status:
  - Last sync: formatted timestamp
  - Next refresh: countdown or "Continuous (WebSocket)"
  - Background status: "Connected" or "Reconnecting..."
- User Profile:
  - FQDN: credentials.fqdn
  - Login: credentials.username
- Actions:
  - Manual Sync: Re-run initial index loads
  - Disconnect: Close socket, clear credentials, navigate to auth
- Technical Details (collapsible):
  - App version, WebSocket URL, raw connection state, error details

3.7 DevicesView (devices_screen.dart)
Purpose: Device list with search/filter

Implementation:
- Device List: ListView.builder from selectDevicesByType(filter)
- Device Card:
  - Icon by device type (Switch/AP/ONT)
  - Name, IP, MAC
  - Online/Offline status indicator
  - Issue count badge (red for critical)
- Search Bar: Filter by name, MAC, serial number (debounced 300ms)
- Filter Buttons: All | Switch | AP | ONT
- Phase Filter: Optional toggle for deployment phase (if applicable)
- Swipe to Delete:
  - Show confirmation dialog
  - Send destroy_resource (resource_type = devices, id = device.id)
  - Optimistic removal from UI
  - Rollback on error with toast
- Pull-to-refresh: Re-run index load for devices
- Tap: Navigate to DeviceDetailView with device.id

3.8 IssuesView (issues_screen.dart -> notifications_screen.dart)
Purpose: Centralized issue list

Implementation:
- Issue List: From health_notices (selectIssuesBySeverity()) sorted by severity then time
- Issue Card:
  - Severity indicator (icon + color): critical/warning/info
  - Title and description
  - Device name and room (if applicable)
  - Suggested resolution (from issue.resolution field)
  - Time since detected
- Search: Filter by text in title/description/device name
- Filter Buttons: All | Critical | Warning | Info
- Device Type Filter: All | AP | ONT | Switch
- Sorting: Critical first, then warning, then info; within severity by time
- Tap: Navigate to DeviceDetailView for associated device

3.9 RoomReadinessView (rooms_screen.dart)
Purpose: Room status overview

Implementation:
- Room List/Grid: Responsive layout based on screen width
- Room Card:
  - Room name
  - Status indicator: Ready (green) | Partial (orange) | Down (red) | Empty (gray)
  - Device counts: "3/5 online"
  - Issue count badges by severity
- Search: Filter by room name
- Status Filter: All | Ready | Partial | Down
- Phase Filter: Optional deployment phase filter
- Tap: Navigate to RoomDetailView with room.id
- Pull-to-refresh: Re-run index load for rooms

3.10 RoomDetailView (room_detail_screen.dart)
Purpose: Single room deep dive

Implementation:
- Room Summary Header:
  - Room name
  - Status indicator
  - Device counts: "Online: 3 | Offline: 2 | Total: 5"
  - Total issue count
- Device List: selectDevicesByRoom(roomId)
  - Device cards showing:
    - Type icon, name, model
    - Online/offline status
    - Onboarding progress bar (if in progress)
    - Issue count badge
  - Tap: Navigate to DeviceDetailView
- Issues Accordion: Collapsible sections by severity
  - Critical issues expanded by default
  - Each issue shows title, description, resolution
- Speed Test Section:
  - List of recent speed tests from selectSpeedtestsByRoom(roomId)
  - Run Speed Test button -> create_resource on speed_test_results (client-run test)
- Auto-refresh: Subscribe to resource types (rooms, access_points, media_converters) and filter by roomId

3.11 DeviceDetailView (device_detail_screen.dart)
Purpose: Comprehensive device information

Implementation:
- 4-Tab Layout: Overview | Ports | Images | Advanced

Overview Tab:
- Device Info Table:
  - Name, Type, Model, Firmware
  - IP Address (with copy button)
  - MAC Address (with copy button)
  - Serial Number (with copy button)
  - Uptime, Last Seen
  - Room assignment
- Status Card: Online/Offline with duration
- Onboarding Progress: If not complete, show stage progress bar with description
- Issues Section: List of issues for this device
- Notes Section:
  - Display current note
  - Edit button -> NoteEditView
  - Clear button with confirmation

Device-Specific Sections:
- For AP:
  - LED Control Card: Buttons for Blink | On | Off
  - LED Reference Guide: Expandable guide showing LED patterns and meanings
  - Wireless Info: SSID, Channel, Signal strength, Connected clients
  - Speed Test Results: List with download/upload/latency
- For ONT:
  - Optical Data Card: TX/RX power, wavelength
  - PHY Data Card: Link status, speed, errors
  - Port Info: Port status list
- For Switch:
  - Port List: Table of all ports with status, speed, connected device

Ports Tab:
- Port list with detailed info
- Locked ports indicator
- Connected device links

Images Tab:
- Image Gallery: Grid of thumbnails
- Tap to open interactive viewer (zoom, pan)
- Add Image: Camera/Gallery picker
  - Downsample to max 2000x2000, 90% quality
  - Warn if >5MB
  - Send update_resource with params.images (resource_type = access_points or media_converters)
- Delete Image: Swipe or long-press with confirmation
- Image metadata: Upload time, uploaded by

Advanced Tab:
- Raw JSON data expandable
- Uplink details
- Sync statistics
- Debug information

Auto-refresh: 5-second interval timer OR subscribe to resource types and filter by device.id

3.12 NoteEditView (note_edit_view.dart)
Purpose: Edit device notes

Implementation:
- TextField: Multi-line, max 255 characters
- Character counter: "45/255"
- Save Button: Send update_resource (resource_type = devices, params.note), handle result
- Cancel Button: Discard changes, pop navigation
- Offline support: Queue command if disconnected, show "Queued" indicator

================================================================================
4) DEVICE ONBOARDING STAGES
================================================================================

4.1 Access Point (AP) - 6 Stages
| Stage | Title                              | Description                                    |
|-------|------------------------------------|------------------------------------------------|
| 1     | Awaiting MAC address registration  | AP powered, rXg not detected yet               |
| 2     | AP reachable, awaiting import      | AP has IP, pingable, import not complete       |
| 3     | Onboarding import running          | rXg importing AP, PKI cert generation          |
| 4     | Registered, not approved           | Onboarded but awaits manual approval           |
| 5     | Registered/approved, offline       | Complete onboarding but currently unreachable  |
| 6     | Registered, approved, online       | SUCCESS - Fully operational                    |

4.2 ONT (Optical Network Terminal) - 5 Stages
| Stage | Title                              | Description                                    |
|-------|------------------------------------|------------------------------------------------|
| 1     | ONT not registered with OLT        | Scanned but never seen by OLT                  |
| 2     | Seen by OLT, awaiting registration | Visible to OLT, not registered (may update FW) |
| 3     | Registered, awaiting provisioning  | Registered but ports not provisioned           |
| 4     | ONT offline, fully provisioned     | Provisioning complete but not reachable        |
| 5     | ONT online, fully provisioned      | SUCCESS - Fully operational                    |

4.3 Onboarding UI Components
- Progress Bar: Shows current stage / total stages
- Stage Title: Bold text with current stage name
- Stage Description: Gray text explaining what's happening
- Elapsed Time: "In this stage for 5m 32s"
- Overdue Indicator: Warning badge if >6 minutes in non-success stage

================================================================================
5) SERIAL NUMBER VALIDATIONS
================================================================================

5.1 Device Type Detection by Serial Prefix
- AP (Access Point): Must start with "1K9", "1M3", or "1HN"
- ONT (Media Converter): Must start with "ALCL"
- Switch: Must start with "LL"

5.2 Barcode Formats Supported
- QR Code: For credentials and device lookup
- Code128: For device serial numbers

5.3 Scan Accumulation Window
- 6-second window for multi-barcode scanning (ONT/AP may have multiple labels)
- Auto-merge scans within window
- Auto-revert to default mode after 8 seconds of no serial

================================================================================
6) DEVICE REGISTRATION WORKFLOW
================================================================================

6.1 Unassigned/Designed Device Concept
- "Designed Device": Pre-created device record in rXg without hardware assigned
- "Unassigned Device": Device with placeholder MAC/Serial (empty, 'null', 'placeholder')
- Field technician assigns physical hardware to designed device

6.2 Registration Bottom Sheet Flow
1. Scan barcode -> Detect device type from serial prefix
2. Show bottom sheet modal:
   - Header: "Register [AP/ONT/Switch]"
   - Scanned data: MAC and/or Serial Number
3. Room Selection:
   - Searchable dropdown from rooms store
   - Required before proceeding
4. Device Assignment Options:
   a. "Create New Device" button
   b. "Assign to Existing" dropdown (shows unassigned devices in selected room)
5. Mismatch Detection:
   - If scanned data differs from selected device, show comparison:
     | Field    | Expected  | Scanned   |
     |----------|-----------|-----------|
     | MAC      | AA:BB:... | CC:DD:... |
   - User must confirm to proceed
6. Hold-to-Confirm Button:
   - Circular progress button
   - User must hold for 2 seconds to submit
   - Prevents accidental registration
7. Result:
   - Success: Toast + navigate to device detail
   - Error: Error message + stay on scanner

================================================================================
7) UI PATTERNS & COMPONENTS
================================================================================

7.1 Navigation Shell Structure
LiveNavBar (Bottom Navigation):
- Home (Dashboard icon)
- Devices (Device icon)
- [Scanner FAB - floating action button in center]
- Issues (Alert icon with badge)
- Rooms (Grid icon)
- Settings (Gear icon, contains Connection status)

Alternative: Scanner as 6th nav item instead of FAB

7.2 Copy-to-Clipboard Pattern
- Icon button next to copyable fields (IP, MAC, Serial)
- On tap: Copy to clipboard + show toast "Copied to clipboard"
- Haptic feedback on copy

7.3 Skeleton Loading Screens
- Device list: 5 skeleton cards with shimmer
- Device detail: Skeleton for each section
- Room list: 6 skeleton cards
- Use shimmer animation during initial load only

7.4 Toast/Snackbar Patterns
- Success (green): "Device registered successfully"
- Error (red): "Failed to save note: [error message]"
- Warning (orange): "Connection unstable"
- Info (blue): "3 commands queued for sync"
- Duration: 3 seconds, dismissible

7.5 Pull-to-Refresh
- All list views support pull-to-refresh
- Triggers index resource_action for the relevant resource types
- Show refresh indicator at top

7.6 Filter State Persistence
- Store active filters in Riverpod state
- Persist across navigation (not cleared on pop)
- Reset button to clear all filters

7.7 Search Debouncing
- Debounce: 300ms
- Minimum characters: 2 (or show all if empty)
- Search icon with clear button when text present

================================================================================
8) LED REFERENCE GUIDE (AP Only)
================================================================================

8.1 LED Patterns
| Pattern        | Meaning                              |
|----------------|--------------------------------------|
| Solid Green    | Online, operating normally           |
| Blinking Green | Booting or firmware update           |
| Solid Orange   | Degraded or warning state            |
| Blinking Orange| Attempting to connect                |
| Solid Red      | Error or offline                     |
| Blinking Red   | Critical error                       |
| Off            | No power or disabled                 |

8.2 LED Control Commands
- Blink: Rapid blink for 30 seconds (identification)
- On: Solid LED on
- Off: LED disabled

8.3 UI Implementation
- Card with three buttons: Blink | On | Off
- "LED Reference" expandable accordion below
- Loading indicator on button while command pending

================================================================================
9) SPEED TEST MODEL
================================================================================

9.1 SpeedTestResult Fields
```
SpeedTestResult {
  id: string,
  roomId: string,
  deviceId: string?,          // AP that ran the test
  status: pending|running|completed|failed,
  downloadMbps: double?,
  uploadMbps: double?,
  latencyMs: double?,
  jitterMs: double?,
  packetLossPercent: double?,
  passed: bool?,              // Met threshold
  threshold: {
    minDownload: double,
    minUpload: double,
    maxLatency: double
  },
  initiatedAt: DateTime,
  completedAt: DateTime?,
  error: string?
}
```

9.2 Speed Test UI
- Results Card: Download/Upload with pass/fail indicators
- Latency & Jitter displayed if available
- "Run Test" button with loading state
- History list sorted by most recent

================================================================================
10) IMAGE MANAGEMENT
================================================================================

10.1 Image Model
```
DeviceImage {
  id: string,
  deviceId: string,
  url: string,
  thumbnailUrl: string?,
  filename: string,
  sizeBytes: int,
  uploadedAt: DateTime,
  uploadedBy: string?,
  metadata: {}
}
```

10.2 Image Upload Flow
1. Tap "Add Image" button
2. Show picker: Camera | Gallery
3. Select/capture image
4. Client-side processing:
   - Downsample to max 2000x2000
   - JPEG quality 90%
   - Warn if >5MB after processing
5. Show upload progress indicator
6. Send update_resource with params.images (resource_type = access_points or media_converters)
7. On success: Add to images list
8. On error: Show retry option

10.3 Image Viewer
- Full-screen modal
- Pinch-to-zoom
- Pan/drag when zoomed
- Swipe left/right for next/previous
- Close button (X) in corner
- Image counter: "2 of 5"

================================================================================
11) COMMAND QUEUE & OFFLINE BEHAVIOR
================================================================================

11.1 Queue Structure
```
QueuedCommand {
  id: uuid,
  type: string,
  payload: {},
  createdAt: DateTime,
  retryCount: int,
  status: pending|sending|failed
}
```

11.2 Queue Behavior
- Commands queued when connection.status != ready
- Persist queue to disk (SQLite or SharedPreferences)
- On reconnect: Flush queue in order, with retry logic
- Max retries: 3 per command
- Show queue status in UI (pending count badge)

11.3 Conflict Resolution
- No explicit version conflict codes are provided; handle 404/422 by rolling back optimistic UI changes
- On error: Show error toast and request a fresh record via resource_action show

11.4 Optimistic Updates
- Apply change to local store immediately
- Show pending indicator on affected item
- On success: Remove pending indicator
- On error: Rollback change, show error

================================================================================
12) DEVICE-SPECIFIC DATA MODELS
================================================================================

12.1 ONT Optical/PHY Data
```
OntOpticsData {
  deviceId: string,
  txPowerDbm: double?,        // Transmit power
  rxPowerDbm: double?,        // Receive power
  wavelengthNm: double?,      // Wavelength in nanometers
  temperature: double?,       // Module temperature
  voltage: double?,           // Supply voltage
  laserBiasCurrent: double?,  // Laser bias current
  updatedAt: DateTime
}

OntPhyData {
  deviceId: string,
  linkStatus: up|down,
  speed: string,              // "1Gbps", "10Gbps"
  duplex: full|half,
  mtu: int,
  rxErrors: int,
  txErrors: int,
  rxDropped: int,
  txDropped: int,
  updatedAt: DateTime
}
```

12.2 Switch Port Data
```
SwitchPort {
  id: string,
  portNumber: int,
  name: string?,
  status: up|down|disabled,
  speed: string?,             // "1Gbps", "100Mbps"
  duplex: full|half|auto,
  vlan: int?,
  poeEnabled: bool?,
  poeStatus: string?,
  connectedDevice: {
    type: ap|ont|unknown,
    id: string?,
    name: string?,
    mac: string?
  }?,
  trafficStats: {
    rxBytes: int,
    txBytes: int,
    rxPackets: int,
    txPackets: int
  }?,
  lastStateChange: DateTime?
}
```

12.3 Issue Model
```
Issue {
  id: string,
  deviceId: string,
  roomId: string?,
  type: offline|config_error|performance|compliance|documentation,
  severity: critical|warning|info,
  title: string,
  description: string,
  resolution: string?,        // Suggested fix
  detectedAt: DateTime,
  resolvedAt: DateTime?,
  metadata: {}
}
```
Note: Map health_notices fields into this shape (severity/title/description/resolution).

================================================================================
13) DEEPLINK SUPPORT
================================================================================

13.1 Deeplink URL Scheme
- Scheme: fdk:// or attfetool://
- Login: fdk://login?fqdn=...&apiKey=...&login=...
- Also supports: fdk://login?data={base64_json}

13.2 Deeplink Handling Flow
1. App receives deeplink intent
2. Parse URL parameters or decode base64 data
3. Validate: FQDN format, API key length (min 32 chars)
4. Show confirmation dialog with server info
5. On confirm: Connect ActionCable with API key (Authorization header or api_key param)
6. On success: Navigate to MainView
7. On error: Show error, stay on auth screen

13.3 Deduplication
- Track last processed URI + timestamp
- Ignore same URI within 30 seconds
- Prevents double-processing on app resume

================================================================================
14) PHASE FILTER (Deployment Phases)
================================================================================

14.1 Phase Concept
- Phases represent deployment stages of a property
- Used for large rollouts where rooms are installed in batches
- Phase values: 1, 2, 3, ... or named phases

14.2 Phase Assignment
- Rooms assigned to phases during design/planning
- Devices inherit phase from their assigned room
- Phase stored in room.metadata.phase or device.metadata.phase

14.3 Phase Filter UI
- Dropdown or chip selector: "All Phases" | "Phase 1" | "Phase 2" | ...
- Applied in DevicesView, RoomsView, IssuesView
- Combined with other filters (type, status, search)

================================================================================
15) MIGRATION STRATEGY
================================================================================

The migration from a REST-based API to a real-time WebSocket architecture will be performed carefully to minimize risk and service disruption. This will be achieved using a feature-flag-controlled, phased rollout.

15.1 Phase 1: Foundational Setup (Parallel Systems)
- The existing `RxgApiClient` (REST) will remain fully functional.
- The new WebSocket service and data store will be implemented in parallel.
- A central feature flag, `use_websocket_backend`, will be introduced, defaulting to `false`. This flag can be controlled remotely (e.g., via Firebase Remote Config) to enable the new backend for specific users or user groups.
- A new data provider layer will be created with a single function like `getDataProvider()`. This function will return either the REST client or the new WebSocket client based on the feature flag. All UI views will be refactored to use this abstract provider, not a specific client.

15.2 Phase 2: Canary Release & Validation (Internal Testing)
- The `use_websocket_backend` flag will be enabled for internal testers and a small percentage of users (e.g., 1-5%).
- **Shadowing:** For this group, the app will *run both data providers*. It will use the WebSocket data to populate the UI but will also fetch data from the REST API in the background.
- **Validation & Logging:** The app will compare the data received from both sources. Any discrepancies, latency differences, or errors will be logged to a remote monitoring service for analysis. This allows us to validate the new backend against the old one in a real-world environment without impacting the user's experience (as they only see the WebSocket data).
- The focus is on achieving data parity and identifying any missed edge cases in the WebSocket implementation.

15.3 Phase 3: Phased Rollout (Incremental User Exposure)
- Once the canary group shows stable results with no significant data discrepancies, the shadowing can be disabled for that group.
- The user base for the `use_websocket_backend=true` flag will be incrementally increased (e.g., 10% -> 25% -> 50% -> 100%) over a period of several days or weeks.
- Key performance indicators (KPIs) such as crash rates, API error rates (for the old client), command failure rates (for the new client), and perceived app performance will be monitored closely during this period.
- Any new issues will trigger a rollback of the flag to a smaller user percentage until the issues are resolved.

15.4 Phase 4: Deprecation & Cleanup
- Once the WebSocket backend is fully rolled out to 100% of users and has been stable for a designated period (e.g., one full release cycle), the old code can be removed.
- The `RxgApiClient` and all related REST-specific logic will be deleted from the codebase.
- The feature flag and the abstraction layer can be removed, and the UI can directly reference the WebSocket data provider.

This strategy ensures a safe, reversible, and data-driven migration, building confidence at each stage before full commitment.

================================================================================
16) ACCEPTANCE CRITERIA
================================================================================

Functional:
- [ ] All 10 views from OldAppReport.txt implemented
- [ ] Live updates reflected without manual refresh
- [ ] Scanner registration works online and queues offline
- [ ] Device details (images, notes, LED, speed tests) update via socket
- [ ] App works after restart using cached data
- [ ] Health score calculated correctly
- [ ] Room readiness status accurate
- [ ] Issue aggregation and filtering works

Performance:
- [ ] Initial load <3 seconds on cached data
- [ ] WebSocket latency <100ms for updates
- [ ] Smooth scrolling on device lists (60fps)
- [ ] Image gallery loads progressively

Reliability:
- [ ] Graceful reconnection on network changes
- [ ] Offline commands queued and synced
- [ ] No data loss on app backgrounding
- [ ] Crash recovery maintains state

================================================================================
17) ERROR HANDLING STRATEGY
================================================================================

A robust error handling strategy is critical for application stability and user trust. Errors arrive as `action: "error"` with `status` and an `error` string.

17.1 Error Code Taxonomy & Client Response

| Status | Category        | Meaning                                            | Client-Side Action                                                              |
|--------|-----------------|----------------------------------------------------|---------------------------------------------------------------------------------|
| 401/403| Authentication  | API key invalid or permission denied               | Show "Permission denied", keep user on auth screen or logout.                   |
| 404    | Validation      | Requested entity not found                         | Roll back optimistic UI changes; show "Not found".                              |
| 422    | Validation      | Invalid input / failed validations                 | Show field-level errors if possible; otherwise show toast.                      |
| 500    | Server          | Internal server error                              | Show generic error; log to crash reporting.                                     |

17.2 UI for Errors
- **Toasts/Snackbars:** For non-critical, transient errors (e.g., validation failure, permission denied).
- **Dialogs:** For critical errors that require user action (e.g., authentication failure).
- **Inline Errors:** For validation errors, displayed directly on the form fields.
- **Logging:** All but the most common validation errors should be logged to a remote service (Sentry, etc.) for analysis.

================================================================================
18) TESTING PLAN
================================================================================

The testing strategy is divided into four layers to ensure comprehensive coverage.

18.1 Unit Tests
- **Reducers:** Test all state transitions. Example: "Given an existing device, a `resource_response` with `resource_action: updated` should replace the record."
- **Selectors:** Verify derived data computation. Example: "Given 10 devices (5 online) and 2 critical issues, `selectHealthScore` must return `(5/10 * 100) - (2 * 5) = 40`."
- **Message Parsing:** Ensure the client can correctly parse all valid message types and gracefully handle malformed messages.
- **Queue Persistence:** Test saving the command queue to disk, loading it on startup, and clearing it on logout.

18.2 Widget Tests
- **View Rendering:** Test that each view/screen correctly renders its state from a mock data store (e.g., a `DeviceDetailView` shows all information for a mock `Device` object).
- **Filter/Search:** Verify that applying a filter on the `DevicesView` correctly updates the list of visible devices.
- **Error States:** Test that views correctly display error messages (e.g., an inline error on a form field).
- **Pull-to-Refresh:** Verify that the pull-to-refresh action on a list view triggers an index `resource_action`.

18.3 Integration Tests
- **Full Connection Lifecycle:** Test the entire state machine: connect -> authorize -> load initial index data -> receive broadcasts -> disconnect -> reconnect.
- **Offline Command Queue:** Go offline, queue multiple commands (e.g., update note, delete device), go back online, and verify the commands are sent in order and the UI updates correctly on success or failure.
- **Initial Load/Broadcast Race Condition:** Send `resource_response` broadcasts during index loads and ensure queued updates apply after initial data.
- **Conflict Resolution:** Force 404/422 errors and verify the client rolls back and refreshes the entity.

18.4 End-to-End (E2E) Tests (Critical User Journeys)
Automated using Flutter's `integration_test` package.

- **Journey 1: First-Time Login & Data Validation**
  1. App starts, user is on `OnboardingView`.
  2. User completes onboarding, lands on `AuthScreen`.
  3. User scans a valid QR code.
  4. App shows loading indicators for "Connecting", "Authorizing", "Loading...".
  5. App navigates to `HomeView`.
  6. **Assert:** The property name is correct and the health score is a valid number between 0 and 100.

- **Journey 2: Offline Device Registration & Sync**
  1. User logs in and is online.
  2. User disables network connectivity.
  3. User navigates to the scanner.
  4. User scans a new device barcode.
  5. User selects a room and fills out the registration form.
  6. User submits the registration.
  7. **Assert:** A "Command Queued" indicator is visible.
  8. User re-enables network connectivity.
  9. **Assert:** The queued indicator disappears, and a "Success" toast appears. The new device is now present in the `DevicesView`.

- **Journey 3: Real-time Update Verification**
  1. Log in on two separate devices/emulators (Client A, Client B).
  2. On Client A, navigate to a specific device's detail view.
  3. On Client A, edit the technician note for that device and save.
  4. **Assert:** On Client B, the same device's detail view updates with the new note within 2 seconds without any user interaction.

- **Journey 4: LED Control & Device Interaction**
  1. User navigates to an Access Point's `DeviceDetailView`.
  2. User taps the "Blink" LED button.
  3. **Assert:** A `resource_action` (resource_type = access_points, crud_action = led) is sent, and a pending indicator is shown.
  4. After the server sends `resource_response`, the pending indicator disappears.

================================================================================
19) PROTOCOL AGREEMENTS & ASSUMPTIONS
================================================================================

To eliminate ambiguity, the following specifications are assumed to be the agreed-upon contract between the client and backend teams.

1.  **WebSocket Endpoint:** The client will connect to ActionCable at `wss://{fqdn}/cable` (or `CABLE_URL` if configured).
2.  **Pagination:** Index responses provide `count`, `page`, `page_size`, `total_pages`; the client requests all pages sequentially as described in section 1.4.
3.  **Property Name:** Property/account metadata is retrieved via standard resource index/show (e.g., `account` or `pms_properties`), not a special snapshot.
4.  **LED Control:** The LED action is `access_points` extra member action `led` (POST) via `resource_action`.
5.  **Speed Tests:** Speed tests are stored in `speed_tests`/`speed_test_results` resources; the client creates results and listens for broadcasts if subscribed.
6.  **Image Uploads:** Images are uploaded via `update_resource` with `params.images` on `access_points` or `media_converters`.
7.  **Offline Command Handling:** The client sends queued CRUD/extra actions in order; failures are handled per status code.
8.  **Resource Types:** Rooms are `pms_rooms`, issues are `health_notices`, devices are `access_points`/`media_converters`/`switch_devices`.

================================================================================
20) RISKS & MITIGATIONS
================================================================================

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| WebSocket protocol mismatch | Low | High | Align with ActionCable protocol and RxgChannel methods; add integration tests. |
| Large initial dataset | Medium | Medium | Use index pagination and staged loading; render incrementally. |
| Image upload failures | Low | Medium | Keep downsampling, add retry with progress, clear error messages. |
| Connection instability | Medium | High | Robust client-side reconnect logic, degraded state UI, offline command queue. |
| State sync issues | Medium | High | Queue broadcasts during initial load; apply last-write-wins by `updated_at`. |
| Cold start performance | Low | Medium | Lazy loading of views, skeleton screens, and persisting data store to disk. |

================================================================================
21) DOCUMENT SUMMARY
================================================================================

This plan covers 21 major sections. The key additions that have brought this plan to its final, actionable state are:
- A clear ActionCable authentication lifecycle aligned to API key/session auth (Section 1.1).
- A race-condition-proof model for loading initial data (Section 1.4).
- A detailed error handling taxonomy and client strategy (Section 17).
- A comprehensive, multi-layered testing plan with concrete E2E user journeys (Section 18).
- A safe, feature-flag-driven migration strategy allowing for a canary release (Section 15).
- A clear set of protocol agreements, removing ambiguity between client and server development (Section 19).

All 10 views from OldAppReport.txt are mapped, all device types are modeled, and all user interactions are specified. The plan is complete and actionable.

================================================================================
END OF PLAN
================================================================================
