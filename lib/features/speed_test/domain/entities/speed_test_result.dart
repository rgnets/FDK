import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:rgnets_fdk/core/services/logger_service.dart';

part 'speed_test_result.freezed.dart';
part 'speed_test_result.g.dart';

@freezed
class SpeedTestResult with _$SpeedTestResult {
  const factory SpeedTestResult({
    int? id,
    @JsonKey(name: 'speed_test_id') int? speedTestId,
    @JsonKey(name: 'test_type') String? testType,
    String? source,
    String? destination,
    int? port,
    @JsonKey(name: 'iperf_protocol') String? iperfProtocol,
    @JsonKey(name: 'download_mbps') double? downloadMbps,
    @JsonKey(name: 'upload_mbps') double? uploadMbps,
    double? rtt,
    double? jitter,
    @JsonKey(name: 'packet_loss') double? packetLoss,
    @Default(false) bool passed,
    @JsonKey(name: 'is_applicable') @Default(true) bool isApplicable,
    @JsonKey(name: 'initiated_at') DateTime? initiatedAt,
    @JsonKey(name: 'completed_at') DateTime? completedAt,
    String? raw,
    @JsonKey(name: 'image_url') String? imageUrl,
    @JsonKey(name: 'access_point_id') int? accessPointId,
    @JsonKey(name: 'tested_via_access_point_id') int? testedViaAccessPointId,
    @JsonKey(name: 'tested_via_access_point_radio_id')
    int? testedViaAccessPointRadioId,
    @JsonKey(name: 'tested_via_media_converter_id')
    int? testedViaMediaConverterId,
    @JsonKey(name: 'uplink_id') int? uplinkId,
    @JsonKey(name: 'wlan_id') int? wlanId,
    @JsonKey(name: 'pms_room_id') int? pmsRoomId,
    @JsonKey(name: 'room_type') String? roomType,
    @JsonKey(name: 'admin_id') int? adminId,
    String? note,
    String? scratch,
    @JsonKey(name: 'created_by') String? createdBy,
    @JsonKey(name: 'updated_by') String? updatedBy,
    @JsonKey(name: 'created_at') DateTime? createdAt,
    @JsonKey(name: 'updated_at') DateTime? updatedAt,
    // Legacy fields for backwards compatibility
    @Default(false) bool hasError,
    String? errorMessage,
    @JsonKey(name: 'local_ip_address') String? localIpAddress,
    @JsonKey(name: 'server_host') String? serverHost,
  }) = _SpeedTestResult;

  const SpeedTestResult._();

  /// Standard fromJson generated by json_serializable
  factory SpeedTestResult.fromJson(Map<String, dynamic> json) =>
      _$SpeedTestResultFromJson(json);

  /// FromJson with validation that corrects potentially swapped speeds
  /// Use this when parsing data from the API to ensure correct values
  static SpeedTestResult fromJsonWithValidation(Map<String, dynamic> json) {
    // Pre-process the JSON to fix swapped speeds before Freezed parsing
    final processedJson = _preprocessJson(json);
    return _$SpeedTestResultFromJson(processedJson);
  }

  /// Factory for creating an error result
  factory SpeedTestResult.error(String message) {
    return SpeedTestResult(
      hasError: true,
      errorMessage: message,
      passed: false,
    );
  }

  /// Pre-process JSON to detect and correct swapped download/upload values
  static Map<String, dynamic> _preprocessJson(Map<String, dynamic> json) {
    final download = _parseDecimal(json['download_mbps']);
    final upload = _parseDecimal(json['upload_mbps']);

    if (download == null || upload == null) {
      return json;
    }

    // Both are 0 - likely incomplete test, don't swap
    if (download == 0 && upload == 0) {
      return json;
    }

    bool shouldSwap = false;
    String? reason;

    // Heuristic 1: Download is suspiciously low AND upload is suspiciously high
    if (download < 5.0 && upload > 50.0) {
      shouldSwap = true;
      reason = 'download too low (<5) and upload too high (>50)';
    }
    // Heuristic 2: Upload is significantly higher than download (10x or more)
    else if (download > 0 && upload > download * 10) {
      shouldSwap = true;
      reason = 'upload is 10x higher than download';
    }

    if (shouldSwap) {
      LoggerService.warning(
        'Detected swapped speeds in result ${json['id'] ?? "unknown"}: '
        '$reason. Original: down=$download up=$upload, '
        'Corrected: down=$upload up=$download',
        tag: 'SpeedTestResult',
      );
      // Create a new map with swapped values
      return {
        ...json,
        'download_mbps': upload,
        'upload_mbps': download,
      };
    }

    return json;
  }

  /// Helper to parse decimal values from various formats
  static double? _parseDecimal(dynamic value) {
    if (value == null) return null;
    if (value is double) return value;
    if (value is int) return value.toDouble();
    if (value is String) return double.tryParse(value);
    return null;
  }

  /// Check if this is an iperf3 test
  bool get isIperfTest =>
      testType?.toLowerCase() == 'iperf3' || testType?.toLowerCase() == 'iperf';

  /// Check if this uses UDP protocol
  bool get isUdp => iperfProtocol?.toLowerCase() == 'udp';

  /// Check if this uses TCP protocol
  bool get isTcp => iperfProtocol?.toLowerCase() == 'tcp';

  /// Get test duration if both timestamps are available
  Duration? get testDuration {
    if (initiatedAt == null || completedAt == null) return null;
    return completedAt!.difference(initiatedAt!);
  }

  /// Check if test is completed
  bool get isCompleted => completedAt != null;

  /// Check if test is still running
  bool get isRunning => initiatedAt != null && completedAt == null;

  /// Check if test has good performance (passed and applicable)
  bool get isHealthy => passed && isApplicable;

  /// Get average speed (mean of download and upload)
  double? get averageSpeedMbps {
    if (downloadMbps == null && uploadMbps == null) return null;
    final down = downloadMbps ?? 0.0;
    final up = uploadMbps ?? 0.0;
    return (down + up) / 2;
  }

  /// Get formatted download speed
  String get formattedDownloadSpeed {
    if (downloadMbps == null) return 'N/A';
    if (downloadMbps! < 1000.0) {
      return '${downloadMbps!.toStringAsFixed(2)} Mbps';
    }
    return '${(downloadMbps! / 1000).toStringAsFixed(2)} Gbps';
  }

  /// Get formatted upload speed
  String get formattedUploadSpeed {
    if (uploadMbps == null) return 'N/A';
    if (uploadMbps! < 1000.0) {
      return '${uploadMbps!.toStringAsFixed(2)} Mbps';
    }
    return '${(uploadMbps! / 1000).toStringAsFixed(2)} Gbps';
  }

  /// Get formatted RTT (Round Trip Time)
  String get formattedRtt {
    if (rtt == null) return 'N/A';
    return '${rtt!.toStringAsFixed(2)} ms';
  }

  /// Get formatted jitter
  String get formattedJitter {
    if (jitter == null) return 'N/A';
    return '${jitter!.toStringAsFixed(2)} ms';
  }

  /// Get formatted packet loss
  String get formattedPacketLoss {
    if (packetLoss == null) return 'N/A';
    return '${packetLoss!.toStringAsFixed(2)}%';
  }

  /// Get formatted latency (alias for RTT for backwards compatibility)
  String get formattedLatency => formattedRtt;

  /// Legacy getter for downloadSpeed (maps to downloadMbps)
  double get downloadSpeed => downloadMbps ?? 0.0;

  /// Legacy getter for uploadSpeed (maps to uploadMbps)
  double get uploadSpeed => uploadMbps ?? 0.0;

  /// Legacy getter for latency (maps to rtt)
  double get latency => rtt ?? 0.0;

  /// Legacy getter for timestamp (maps to completedAt or createdAt)
  DateTime get timestamp => completedAt ?? createdAt ?? DateTime.now();
}
