# MEMORY ISSUE INVESTIGATION REPORT: Flutter FDK App OOM Crash

**Date:** 2026-01-06
**Error:** Scudo ERROR: internal map failure (error desc=Out of memory)
**Symptom:** 2,169 unread notifications accumulated, app crashed on sign-out

---

## CRITICAL ISSUE #1: UNBOUNDED NOTIFICATION LIST GROWTH (REAL)

**File:** `lib/core/services/notification_generation_service.dart`
**Lines:** 22, 42, 159-160

**Problem:**
```dart
// Line 22: Single in-memory list with NO SIZE LIMIT
final List<AppNotification> _notifications = [];

// Lines 41-42: CONTINUOUSLY ACCUMULATING notifications every 2 minutes
_notifications.addAll(newNotifications);

// Line 159: Returns ENTIRE list every time
List<AppNotification> getAllNotifications() {
  return List.from(_notifications);
}
```

**Root Cause:** The `NotificationGenerationService` maintains an unbounded list that grows with every background refresh cycle. Every 2 minutes, the `BackgroundRefreshService` calls `generateFromDevices()` which appends to `_notifications` without any pruning or TTL.

**Impact:**
- Initial notifications accumulate
- Same devices generate duplicate notifications on each cycle
- No expiry or max-size enforcement
- After ~1000+ refresh cycles, 2,169 notifications are held in memory

---

## ISSUE #2: STATE-CHANGE NOT USED (ROOT CAUSE OF DUPES)

**File:** `lib/core/services/notification_generation_service.dart`
**Lines:** 18-25, 35-60, 74-143

**Problem:**
```dart
final Map<String, String> _previousDeviceStates = {};
final List<AppNotification> _notifications = [];
// ...
final previousStatus = _previousDeviceStates[device.id];
// previousStatus is never used to gate notifications
final deviceNotifications = _generateDeviceNotifications(device, now, previousStatus);
newNotifications.addAll(deviceNotifications);
```

**Impact:**
- Notifications are generated on every refresh, not just on state transitions.
- If a user marks a notification as read, a new one is generated on the next cycle.
- This turns the refresh loop into a notification factory.

---

## ISSUE #3: STREAM CONTROLLERS NOT DISPOSED (POTENTIAL)

**File:** `lib/core/services/notification_generation_service.dart`
**Lines:** 12-13, 198-200

**Problem:**
```dart
// Lines 12-13: Broadcast stream controllers
final _notificationController = StreamController<AppNotification>.broadcast();
final _notificationListController = StreamController<List<AppNotification>>.broadcast();

// Line 198-200: dispose() method exists but may not be called
void dispose() {
  _notificationController.close();
  _notificationListController.close();
}
```

**Issue:** The `dispose()` method exists but the provider in
`lib/core/providers/core_providers.dart` does not call `ref.onDispose()`.
The service is a singleton for the app lifetime, so this is not the root
cause of growth, but it is still a lifecycle leak during sign-out/scope changes.

---

## ISSUE #4: WEBSOCKET MESSAGE STREAMING (NOT THE OOM ROOT)

**File:** `lib/core/services/websocket_service.dart`
**Lines:** 73-74, 231-237, 351

**Problem:**
```dart
// Lines 73-74: Broadcast stream controllers
final _stateController = StreamController<SocketConnectionState>.broadcast();
final _messageController = StreamController<SocketMessage>.broadcast();

// Lines 231-237: Every message stored in memory
_messageController.add(
  SocketMessage(
    type: type,
    payload: payload,
    headers: headers,
    raw: decoded,  // Raw decoded message stored
  ),
);

// Line 351: Global variable holding last message
SocketMessage? _lastMessage;
```

**Reality Check:**
- Only the **last** message is retained (`_lastMessage`).
- Messages are streamed, not stored in a growing list.
- This is not an unbounded memory growth source on its own.

---

## ISSUE #5: BACKGROUND REFRESH DRIVES THE LEAK (REAL)

**File:** `lib/core/services/background_refresh_service.dart`
**Lines:** 30-32, 42-52, 154-158

**Problem:**
```dart
// Lines 42-52: Continuous background refresh loop
void startBackgroundRefresh() {
  Future<void>.delayed(_initialDelay, _performRefresh);

  _refreshTimer?.cancel();
  _refreshTimer = Timer.periodic(_refreshInterval, (_) {
    _performRefresh();
  });
}
```

**Data Flow Problem:**
1. Started in `main.dart` (line 72) with `ref.read(backgroundRefreshServiceProvider).startBackgroundRefresh()`
2. Runs every 2 minutes
3. Each cycle calls `generateFromDevices()` which adds to the unbounded `_notifications` list
4. After 1000+ cycles: 2,169 notifications accumulated
5. No mechanism to stop or reset

---

## ISSUE #6: DERIVED PROVIDERS (CPU COST, NOT LEAK)

**File:** `lib/features/notifications/presentation/providers/device_notification_provider.dart`
**Lines:** 24-244

**Problem:** Multiple derived providers watch `deviceNotificationsNotifierProvider`:
- `unreadDeviceNotifications` - filters entire list
- `unreadDeviceNotificationCount` - counts entire list
- `notificationsByPriority` - filters entire list
- `deviceNotificationsByType` - filters entire list
- `urgentNotifications` - filters entire list
- `mediumNotifications` - filters entire list
- `lowNotifications` - filters entire list
- `deviceNotifications` - filters by device ID
- `roomNotifications` - filters by location

**Reality Check:** These lists are short‑lived and GC’d. This is more of a
CPU churn issue than a sustained memory leak.

---

## ROOT CAUSE SUMMARY (REVISED)

The OOM crash is caused by a **CASCADING MEMORY LEAK**:

1. **Background refresh runs every 2 minutes** -> calls `generateFromDevices()`
2. **State transitions are ignored** -> duplicate notifications get created
3. **Unbounded list grows** -> `_notifications.addAll()` has NO max size or TTL
4. **No cleanup on sign‑out** -> notification store persists through sessions

**Reality Check:** 2,169 notifications is likely only a few MB. This alone may
not explain a Scudo OOM. There may be additional memory pressure elsewhere,
but this list growth is still a real, fixable issue.

---

## FILES WITH ISSUES SUMMARY

| File | Lines | Issue |
|------|-------|-------|
| `lib/core/services/notification_generation_service.dart` | 22, 42, 159 | Unbounded list growth, no cleanup |
| `lib/features/notifications/presentation/providers/notifications_domain_provider.dart` | 12 | `keepAlive: true` prevents disposal |
| `lib/core/providers/core_providers.dart` | 98-101 | Service provider no lifecycle management |
| `lib/core/services/websocket_service.dart` | 73-74, 231-237, 351 | Unbounded message streaming |
| `lib/core/services/background_refresh_service.dart` | 30-32, 42-52 | Continuous refresh driving accumulation |
| `lib/features/notifications/presentation/providers/device_notification_provider.dart` | 24-244 | Multiple providers creating filtered copies |
| `lib/core/providers/websocket_providers.dart` | 26-31, 42-61 | Stream listeners not cleaned up |
| `lib/main.dart` | 72 | Background refresh started without cleanup |

---

## RECOMMENDED FIXES (IMPROVED + ACTIONABLE)

### Priority 1 - Critical (Fix immediately)

1. **Generate notifications only on state transitions**
   - File: `lib/core/services/notification_generation_service.dart`
   - Use `previousStatus` to gate offline/online transitions.
   - For note/images, detect transitions (empty -> non‑empty, none -> exists)
     to avoid re‑issuing the same notification every refresh.

2. **Bound the list with a retention policy**
   - Keep the most recent N (e.g., 500) and/or prune anything older than 24–72h.
   - Apply pruning before emitting updated lists.

3. **Deduplicate by key**
   - Key by `(deviceId, type, status)` and only create a new notification if
     the last one is resolved/cleared or the state transitions again.

### Priority 2 - Important

4. **Add lifecycle cleanup**
   - Add `ref.onDispose()` for `NotificationGenerationService`
     (and background refresh) to close streams and stop timers.
   - On sign‑out: clear notifications and reset `_previousDeviceStates`.

5. **Reduce background refresh cadence when idle**
   - Increase interval or disable when app is backgrounded.

6. **Avoid full list copies on every update**
   - Emit deltas (new notifications) and let UI append, or debounce list updates.

### Priority 3 - Nice to have

7. **Use pagination/lazy loading** for notifications
   - Only load visible notifications
   - Virtualize long lists

8. **Instrument memory and notification counts**
   - Log size of `_notifications` and refresh cycles
   - Add guards to warn when counts exceed thresholds

9. **Add explicit tests**
   - Unit tests for transition gating and TTL pruning
   - Integration test to ensure refresh cycles do not grow without bound
